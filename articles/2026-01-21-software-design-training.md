---
title: "わかる！ソフトウェア設計トレーニング を読んだ感想"
emoji: "🗺️"
type: "idea"
topics:
  - "software-design"
published: true
published_at: "2025-01-21 00:50"
---

# はじめに
先日、インターン先の先輩が技術書を発売した。
僕は個人の方が書いた技術書を買ったことが無かったのだが、尊敬する先輩が書いたというので試しに買ったみたところ、完成度が高くて驚いた。そして、シンプルに内容が技術書としてとてもためになったので、メモ書きのようなものになってしまうが、感想や学びをブログとして書くことにした。
実際個人で書かれた技術書としてはかなり売れたらしいので、気になる方・ソフトウェア設計について学びたい方はぜひ読んでみていただきたい。

前提として、コードを書く実務経験はインターンを初めて半年ほどで、ソフトウェア設計についてはほとんど初心者です。

# 読んで印象に残ったところのメモ

## 1章
- 設計と設計理論は別物
「アーキテクチャ」と「アーキテクチャパターン」といった対応関係の話と似ている。個別の設計を学ぶのと、どの設計を適用するのかを考えるのは少しニュアンスが違う。

- 同期処理と非同期処理
同期処理は処理の整合性が重要で、**数秒以内に終わるもの**
非同期処理は **UIに対するフィードバックの速さ** が重要なもの・
  - つまり裏側の処理に時間がかかるものとも言える
こういうを判断するのに必要なのがドメインの言葉で話すということ。

- 「抽象的な設計理論を習得するときに必要なのは、「場合による」という言葉をなるべく使わないことです」　
こういう言い回しというか、読者に訴えかける感じの文体がとても文章上手いなと思う。

- ドメイン知識の適切な運用
分析力、応用力、抽象的な設計理論の知識

## 2章
### 2.1 ソフトウェアモジュールの2種類のわかりやすさ
モジュール分割をする理由が、誰にとってモジュールがわかりやすいべきか
汎用性：標準ライブラリ
  -  固有のドメイン知識に依存しないため、モジュール単体で理解しやすい「わかりやすさ」
限定性：ローカル変数
  - 特定の親に依存して、処理や引数を明示的にどのような意図で使われるか説明できることによる「わかりやすさ」
ドメイン駆動開発において基本データ型への固執はアンチパターン。システム固有の型として`Money`、`Email`などの値オブジェクトを使用する。

### 2.2 保守性を構成する4要素とそれを実現する関心の分離
修正しやすさ。理解しやすさ。テストしやすさ。再利用しやすさ。
親と子に別れる。子が親についてどの程度の情報を持っているか。

自分が個人開発をした時に、まさに難しいなと思った問題。競プロとかでも関数を作成・呼び出す時とかにどんな引数・型を設定すべきかで
迷った挙句エラー出たりする。

子が親を忘れられる2種類の分類
  - 他の手順を忘れるタイプ
    - 他の手順から分離させられるならなるべく分離させたほうがいい
  - 呼び出し意図を忘れるタイプ
    - モジュールが汎用的な内容なら再利用性を高めるために呼び出し意図を忘れる必要がある
    - 再利用性が損なわれない範囲でなるべく目的や意図を記述すべき

### 2.3 モジュールの呼び出し可能範囲を明示する
- モジュールには呼び出し範囲・規模の多様性がある
「関心の分離」を実現したディレクトリ構成の話
限定的なモジュールほど、深い階層・内側に配置する。
汎用的なモジュールXの配置場所はXを呼び出し可能なすべてのモジュールの配置された場所の最近共通祖先にすべき。

### 2.4 インターフェイスによる汎用処理の抽出
` filter(predicate: (element: T) => boolean): T[]; `
Tはジェネリクスの型引数


### 2.5 章末問題
- 汎用的なモジュールを限定的な使い方をする問題：車輪の再発明、DRY違反
- 限定的なモジュールを汎用的な使い方をする問題：単一責任原則の違反
振り返る時に問題だけ振り返るという使い方ができるのはありがたい。

## 3章
- 非機能要件とは？
- 品質・目標・手段のフレームワーク
とそのずれ(グットハートの法則など)
- 非機能要件の測定方法には能動的なものと受動的なものがある

### 3.3 品質と目標を近づける

### 3.4 目標と手段を近づける
- 失敗から学ぶ
- PDCAサイクル
- データを用いた意思決定



## 4章
親が子の情報をどの程度忘れられるかは、**メンタルモデル**に依存する。子に対してどのような処理が行われるかの期待とそれがどの程度うまく実現できているか。
これによって関心の分離が実現できているときに抽象化できているという。
「処理に対して簡潔で認知コストの低いメンタルモデルが提供できているか」

これを見ると、命名(プラスでargument, return valueを加えたシグネチャ)を読む・書く時に意識するのは抽象化を使ったコードリーディングにおいてすごく大事。コミットメッセージ、PR overview、関数の命名はAIが人間より(少なくとも自分より)かなり上手いし速いと思う。最近のAIの流れとしては、「コードの読み書き」という人間活動自体を抽象化して代替したものを使用することができるとも言える（もちろん精度・粒度・文脈に応じた使用が必要）.段落を抽象化しながら読むと言ったコツはコードリーディングだけじゃなくて読み物全般に言えそうで、それの重要なファクターがメンタルモデルとも言えるのか。

### 4.4 テスト駆動開発
説明テスト
品質保証テスト：決定表、境界値分析、同値分割、カバレッジ
Red, Green, Refactorのサイクル
テストファーストの開発自体がテスタビリティを向上させる

コラムがすごい：「優れたエンジニアは抽象化を突破する」
(コードリーディングだけでない)文章やドキュメントを理解するときの癖として、抽象化に頼りすぎている感は自分の中である。例えば英語の試験とかもこの抽象化の力でパラグラフを全部読まずに内容を理解していることが多いがする。特にAIはこの力が強いと思う。この力はもちろん大事なのだが、ここで触れられている包括的な実装内容・コンテキストを背景知識を含めてを全部理解する力、は特定の分野で秀でるためには重要。分野のさまざまな事象について、抽象的なエッセンスとその内容を何度も往復してそれを記憶しているから=時間を使っているからこそ精度が高くて素早いアウトプットが出せる。
この辺の抽象化と具体化の話で面白い記事があったので共有する：https://zenn.dev/339/articles/83caa21b9ad736